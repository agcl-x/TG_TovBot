import telebot
import json
from telebot import types
import schedule
import time
import threading
import emoji
import sqlite3
import random
from datetime import datetime


# === –õ–æ–≥—É–≤–∞–Ω–Ω—è ===
def log(user_id, message):
    log_text = f"[{datetime.now().strftime("%H:%M %d.%m.%Y")}]\t{message}\n"
    log_path = f"logs\\{user_id}.log"
    with open(log_path, "a", encoding="utf-8") as f:
        f.write(log_text)

def log_sys(message):
    log("system", message)

with open('config.json', 'r', encoding='utf-8') as f:
    config = json.load(f)
    log_sys('Config.json read to config')

szBotToken = config["botToken"]
bot = telebot.TeleBot(szBotToken)

scheduler_running = True

currArt = ""
currOrderCode = ""
tempOrder = {
    "customerID": "",
    "date": "",
    "ifSended": False,
    "TTN": "",
    "orderTovarList": []
}
tempUser = {
    "id":0,
    "PIB":"",
    "phone":"",
    "address":""
}
# ================ SUPPORT FUNCTION ================
def fetch_as_dicts(query, params=()):
    log_sys(f"Initiating connection to database( {config["pathToDatabase"]} )")
    with sqlite3.connect(config['pathToDatabase']) as conn:
        log_sys("Successfully connected to database")
        cur = conn.cursor()
        cur.execute(query, params)
        columns = [desc[0] for desc in cur.description]
        log_sys("Data was successfully fetched")
        return [dict(zip(columns, row)) for row in cur.fetchall()]

def SQLmake(query, params=()):
    log_sys(f"Initiating connection to database( {config["pathToDatabase"]} )")
    with sqlite3.connect(config['pathToDatabase']) as conn:
        log_sys("Successfully connected to database")
        cur = conn.cursor()
        cur.execute(query, params)
        conn.commit()
        return cur.lastrowid

def has_emoji(text: str) -> bool:
    return any(char in emoji.EMOJI_DATA for char in text)

def isInt(a):
    try:
        int(a)
        return True
    except ValueError:
        return False

def ifThisCorrectTovar(message):
    global currArt, tempOrder

    log(message.from_user.id, "ifThisCorrectTovar called")

    if message.text in ["/start", "üè†Ô∏èÔ∏è–ù–∞ –≥–æ–ª–æ–≤–Ω—É"]:
        log(message.from_user.id, '"To main page" button pressed or "/start" command used')
        tempOrder = {
            "customerID": "",
            "date": "",
            "ifSended": False,
            "TTN": "",
            "orderTovarList": []
        }
        start(message)
        return

    found = False

    if message.caption:
        log(message.from_user.id, 'Forwarded message detected. Checking if the message is correct')
        if message.caption.startswith("üî•"):
            log(message.from_user.id, 'Message is correct. Getting data from forwarded message was started')
            textList = message.caption.split("\n")
            for text in textList:
                if "–ê—Ä—Ç.: " in text:
                    currArt = text.replace("–ê—Ä—Ç.: ", "").strip()
                    log(message.from_user.id, f'Current article: {currArt}')
                    log(message.from_user.id, 'Trying getting data from database')
                    try:
                        data = fetch_as_dicts('SELECT * FROM products WHERE art = ?', (currArt,))[0]
                        data_prop = fetch_as_dicts('SELECT * FROM product_properties WHERE art = ?', (currArt,))
                        found = True
                        log(message.from_user.id, 'Data was successfully got')
                    except Exception as e:
                        log(message.from_user.id, f'[ERROR] Can`t find article {currArt} in database: {e}')
                        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
                        markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"),
                                   types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
                        bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –ø—Ä–æ —Ü–µ–π —Ç–æ–≤–∞—Ä –Ω–∞ –¥–∞–Ω–∏–π –Ω–µ–º–æ–∂–ª–∏–≤–∞.",
                                         reply_markup=markup)

                    for i in data_prop:
                        if i["availability"]>0:
                            data["sizeList"].append(i["property"])
                    if len(data_prop) == 0:
                        log(message.from_user.id, 'List product propeties is empty. Running reCheckStatus')
                        reCheckStatus(message)
                        log(message.from_user.id, 'Rerunning current function')
                        ifThisCorrectTovar(message)
                    tempOrder["orderTovarList"].append({"art": currArt, "prop": "", "count": 0})
                    log(message.from_user.id, 'Current article was added to tempOrder')

                    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
                    row = []
                    counter = 0
                    for prop in data["sizeList"]:
                        row.append(types.KeyboardButton(prop))
                        counter += 1
                        if counter % 3 == 0:
                            markup.row(*row)
                            row = []
                    if row:
                        markup.row(*row)
                    log(message.from_user.id, 'Size buttons was created')
                    msg = bot.send_message(message.chat.id, "üìè–í–∏–±–µ—Ä—ñ—Ç—å —Ä–æ–∑–º—ñ—Ä", reply_markup=markup)
                    bot.register_next_step_handler(msg, handle_prop_selection)
                    return

    else:
        log(message.from_user.id, 'Forwarded message not detected. Working in default mode')
        currArt = message.text.strip()
        log(message.from_user.id, f'Current article: {currArt}')
        log(message.from_user.id, 'Trying getting data from database')
        try:
            data = fetch_as_dicts('SELECT * FROM products WHERE art = ?', (currArt,))[0]
            data_prop = fetch_as_dicts('SELECT * FROM product_properties WHERE art = ?', (currArt,))
            found = True
            log(message.from_user.id, 'Data was successfully got')
        except Exception as e:
            log(message.from_user.id, f'[ERROR] Can`t find article {currArt} in database: {e}')
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"),
                       types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
            bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –ø—Ä–æ —Ü–µ–π —Ç–æ–≤–∞—Ä –Ω–∞ –¥–∞–Ω–∏–π –Ω–µ–º–æ–∂–ª–∏–≤–∞.",
                             reply_markup=markup)

    if found:
            data["availabilityForProperties"] = {}
            data["priceForProperties"] = {}
            for i in data_prop:
                if i["availability"]>0:
                    data["availabilityForProperties"][i["property"]] = i["availability"]
                    data["priceForProperties"][i["property"]] = i["price"]
            log(message.from_user.id, 'priceForProperties and availabilityForProperties was created')
            log(message.from_user.id, 'Start forming message')
            szResultMessage = formMessageText(data, message.from_user.id)
            images = []
            log(message.from_user.id, 'Trying to get images')
            try:
                if data.get("frontImage"):
                    images.append(open(data["frontImage"], 'rb'))
                    log(message.from_user.id, 'Front image was opened')
                if data.get("backImage"):
                    images.append(open(data["backImage"], 'rb'))
                    log(message.from_user.id, 'Back image was opened')
            except Exception as e:
                log(message.from_user.id, f'[ERROR] Failed to get image for {currArt}: {e}')

            if images:
                media = []
                for i, img in enumerate(images):
                    if i == 0:
                        if szResultMessage != "NULL":
                            media.append(types.InputMediaPhoto(img, caption=szResultMessage, parse_mode='HTML'))
                        else:
                            log(message.from_user.id, '[ERROR] Can`t send unformed message')
                            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
                            markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"),
                                       types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
                            bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –ü–æ–º–∏–ª–∫–∞ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Ç–µ–∫—Å—Ç—É.",
                                             reply_markup=markup)
                            return
                    else:
                        media.append(types.InputMediaPhoto(img))
                bot.send_media_group(message.chat.id, media)
                log(message.from_user.id, 'Image was sent successfully')
            else:
                bot.send_message(message.chat.id, szResultMessage, parse_mode='HTML')
                log(message.from_user.id, 'Message was sent without images')

            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            markup.add(types.KeyboardButton("‚úÖ–¢–∞–∫"), types.KeyboardButton("‚ùå–ù—ñ"))
            msg = bot.send_message(message.chat.id, "–ß–∏ —Ü–µ —Ç–∞ —Ñ–æ—Ä–º–∞ —è–∫—É –≤–∏ —Ö–æ—á–µ—Ç–µ –∑–∞–º–æ–≤–∏—Ç–∏?", reply_markup=markup)
            bot.register_next_step_handler(msg, handle_tovar_selection)

    if not found:
        log(message.from_user.id, f'[ERROR] Can`t find {currArt} in database')
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"), types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
        bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –ê—Ä—Ç–∏–∫—É–ª –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.", reply_markup=markup)

def handle_tovar_selection(message):
    global tempOrder, currArt

    log(message.from_user.id, "handle_tovar_selection called")

    if message.text in ["/start", "üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"]:
        log(message.from_user.id, '"To main page" button pressed or "/start" command used')
        start(message)
        tempOrder = {
            "customerID": "",
            "date": "",
            "ifSended": False,
            "TTN": "",
            "orderTovarList": []
        }
        return

    if message.text == "‚úÖ–¢–∞–∫":
        log(message.from_user.id, f'Current article: {currArt}')
        log(message.from_user.id, 'Trying getting data from database')
        try:
            product_data = fetch_as_dicts("SELECT art FROM products WHERE art = ?", (currArt,))
            if not product_data:
                log(message.from_user.id, f'[ERROR] Can`t find article {currArt} in database')
                markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
                markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"),
                           types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
                bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –ø—Ä–æ —Ü–µ–π —Ç–æ–≤–∞—Ä –Ω–∞ –¥–∞–Ω–∏–π –Ω–µ–º–æ–∂–ª–∏–≤–∞.",
                                 reply_markup=markup)
                return
            data = product_data[0]
            log(message.from_user.id, 'Data was successfully got')
            data["availabilityForProperties"] = {}
            log(message.from_user.id, 'Trying tempAvailabilityForProperties from database')
            tempAvailabilityForProperties = fetch_as_dicts(
                "SELECT property, availability as count FROM product_properties WHERE art = ?",
                (currArt,)
            )
            log(message.from_user.id, 'tempAvailabilityForProperties was successfully got')
        except Exception as e:
            log(message.from_user.id, f'[ERROR] Can`t find article {currArt} in database: {e}')
            tempOrder["customerID"] = ""
            tempOrder["date"] = ""
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            markup.add(
                types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"),
                types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É")
            )
            bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –ê—Ä—Ç–∏–∫—É–ª –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.", reply_markup=markup)
            return

        tempOrder["orderTovarList"].append({"art": currArt, "prop": "", "count": 0})
        log(message.from_user.id, 'Current article was added to tempOrder')

        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        row = []
        counter = 0

        for prop in tempAvailabilityForProperties:
            property_name = prop['property']
            count = prop['count']
            if count != 0:
                row.append(types.KeyboardButton(property_name))
                counter += 1
                if counter % 3 == 0:
                    markup.row(*row)
                    row = []

        if row:
            markup.row(*row)

        log(message.from_user.id, 'Size buttons was created')
        msg = bot.send_message(message.chat.id, "–í–∏–±–µ—Ä—ñ—Ç—å —Ä–æ–∑–º—ñ—Ä", reply_markup=markup)
        bot.register_next_step_handler(msg, handle_prop_selection)
        return
    else:
        log(message.from_user.id, 'Running rechoosing article function')
        make_order(message)

def handle_prop_selection(message):
    global tempOrder, currArt

    log(message.from_user.id, "handle_prop_selection called")

    if message.text in ["/start", "üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"]:
        log(message.from_user.id, '"To main page" button pressed or "/start" command used')
        tempOrder = {
            "customerID": "",
            "date": "",
            "ifSended": False,
            "TTN": "",
            "orderTovarList": []
        }
        start(message)
        return

    prop = message.text.strip()
    if not tempOrder["orderTovarList"]:
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"), types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
        bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –°–ø–∏—Å–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω—å –ø–æ—Ä–æ–∂–Ω—ñ–π.", reply_markup=markup)
        log(message.from_user.id, f'[ERROR] tempOrder["orderTovarList"] is empty')
        return

    lastAddedTovar = tempOrder["orderTovarList"][-1]
    targetArt = lastAddedTovar["art"]
    isAlreadyAdded = False
    currTovar = {}
    currData = {}

    log(message.from_user.id, 'Checking if product is already in orderTovarList')
    for tovar in tempOrder["orderTovarList"]:
        if tovar["art"] == targetArt and tovar["prop"] == prop:
            log(message.from_user.id, f'{targetArt}:{prop} is already in orderTovarList')
            isAlreadyAdded = True
            currTovar = tovar

    log(message.from_user.id, 'Trying getting data from database')
    try:
        currData = fetch_as_dicts("SELECT property, availability FROM product_properties WHERE art = ?", (currArt,))
        log(message.from_user.id, 'Data was successfully got')
        availability_dict = {item['property']: int(item['availability']) for item in currData}
        log(message.from_user.id, 'Availability dictionary was created')
    except Exception:
        log(message.from_user.id, f'[ERROR] Can`t find {currArt} from database')
        availability_dict = {}
        log(message.from_user.id, 'Availability dictionary was deleted')

    if availability_dict:
        available_count = availability_dict.get(prop, 0)

        if prop not in availability_dict:
            log(message.from_user.id, f'[ERROR] Selected property "{prop}" not found in DB for art {currArt}')
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            counter = 0
            row=[]
            for property_name, count in availability_dict.items():
                if count != 0:
                    row.append(types.KeyboardButton(property_name))
                    counter += 1
                    if counter % 3 == 0:
                        markup.row(*row)
                        row = []
            if row:
                markup.row(*row)

            markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"), types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
            msg = bot.send_message(message.chat.id,
                             f"‚ùå –ü–æ–º–∏–ª–∫–∞: –û–±—Ä–∞–Ω–∏–π —Ä–æ–∑–º—ñ—Ä <b>{prop}</b> –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –±–∞–∑—ñ. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.",
                             parse_mode='HTML', reply_markup=markup)
            bot.register_next_step_handler(msg, handle_prop_selection)
            return
        if isAlreadyAdded:
            if currTovar["count"] + 1 <= available_count:
                currTovar["count"] += 1
                markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
                markup.add(types.KeyboardButton("‚úÖ–¢–∞–∫"), types.KeyboardButton("‚ùå–ù—ñ"))
                log(message.from_user.id, f'{targetArt} {prop} count incremented')
                msg = bot.send_message(message.chat.id, f"‚úÖ –î–æ–¥–∞–Ω–æ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è: {targetArt}, —Ä–æ–∑–º—ñ—Ä {prop}. –î–æ–¥–∞—Ç–∏ —â–µ?", reply_markup=markup)
                bot.register_next_step_handler(msg, handle_adding_tovar_to_order)
            else:
                markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
                markup.add(types.KeyboardButton("‚úÖ–¢–∞–∫"), types.KeyboardButton("‚ùå–ù—ñ"))
                log(message.from_user.id, f'{targetArt} {prop} –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∏–π —É –ø–æ—Ç—Ä—ñ–±–Ω—ñ–π –∫—ñ–ª—å–∫–æ—Å—Ç—ñ')
                del tempOrder["orderTovarList"][-1]
                msg = bot.send_message(message.chat.id, f"–¢–æ–≤–∞—Ä {targetArt} {prop} –≤—ñ–¥—Å—É—Ç–Ω—ñ–π —É –ø–æ—Ç—Ä—ñ–±–Ω—ñ–π –∫—ñ–ª—å–∫–æ—Å—Ç—ñ. –í–∏–±–µ—Ä—ñ—Ç—å —ñ–Ω—à–∏–π.", reply_markup=markup)
                bot.register_next_step_handler(msg, handle_adding_tovar_to_order)
        else:
            if available_count > 0:
                lastAddedTovar["prop"] = prop
                lastAddedTovar["count"] = 1
                markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
                markup.add(types.KeyboardButton("–î–æ–¥–∞—Ç–∏ –Ω–æ–≤–∏–π —Ç–æ–≤–∞—Ä‚ûï"), types.KeyboardButton("–ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏‚û°"))
                log(message.from_user.id, f'{targetArt} {prop} –¥–æ–¥–∞–Ω–æ –¥–æ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è')
                msg = bot.send_message(message.chat.id, f"‚úÖ –î–æ–¥–∞–Ω–æ: {targetArt} {prop}. –ë–∞–∂–∞—î—Ç–µ –¥–æ–¥–∞—Ç–∏ —â–µ —Ç–æ–≤–∞—Ä?", reply_markup=markup)
                bot.register_next_step_handler(msg, handle_adding_tovar_to_order)
            else:
                markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
                markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"), types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
                log(message.from_user.id, f'[ERROR] –¢–æ–≤–∞—Ä {targetArt} {prop} –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∏–π')
                bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –í–∏–±—ñ—Ä –Ω–µ –Ω–∞—è–≤–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä—É.", reply_markup=markup)
    else:
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"), types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
        log(message.from_user.id, f'[ERROR] Can`t find {prop} for {currArt} in database')
        bot.send_message(message.chat.id, "‚ùå –ü–æ–º–∏–ª–∫–∞: –†–æ–∑–º—ñ—Ä –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.", reply_markup=markup)

def handle_adding_tovar_to_order(message):
    global tempOrder

    log(message.from_user.id, "handle_adding_tovar_to_order called")

    if message.text in ["/start", "üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"]:
        log(message.from_user.id, '"To main page" button pressed')
        tempOrder = {
            "customerID": "",
            "date": "",
            "ifSended": False,
            "TTN": "",
            "orderTovarList": []
        }
        start(message)
        return

    elif message.text == "–î–æ–¥–∞—Ç–∏ –Ω–æ–≤–∏–π —Ç–æ–≤–∞—Ä‚ûï":
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        row = []
        log(message.from_user.id, 'Trying getting data from database')
        try:
            DataList = fetch_as_dicts("SELECT * FROM products")
            log(message.from_user.id, 'Data was successfully got')
        except Exception as e:
            log(message.from_user.id, f"[ERROR] Failed to fetch products: {e}")
            DataList = []

        for idx, item in enumerate(DataList):
            row.append(types.KeyboardButton(item["art"]))
            if (idx + 1) % 3 == 0:
                markup.row(*row)
                row = []
        if row:
            markup.row(*row)

        log(message.from_user.id, 'Articles button was created')
        msgText = (
            "ü§î <b>–û–±–µ—Ä—ñ—Ç—å —Ç–æ–≤–∞—Ä</b> –∑–∞ –∞—Ä—Ç–∏–∫—É–ª–æ–º –∞–±–æ –ø—Ä–æ—Å—Ç–æ <b>–ø–µ—Ä–µ—à–ª—ñ—Ç—å</b> –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ –Ω–∞—à–æ–≥–æ –∫–∞–Ω–∞–ª—É üì®\n\n"
            "üÜî –ù–∞–∂–º—ñ—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É –∑ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–º –∞—Ä—Ç–∏–∫—É–ª–æ–º\n\n\t\t–∞–±–æ\n\n"
            "üì≤ –ü–µ—Ä–µ—à–ª—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä—è–º–æ —Å—é–¥–∏ ‚Äî —ñ —è –≤—Å–µ –æ–±—Ä–æ–±–ª—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ!"
        )
        msg = bot.send_message(message.chat.id, msgText, reply_markup=markup, parse_mode="HTML")
        bot.register_next_step_handler(msg, ifThisCorrectTovar)

    else:
        log(message.from_user.id, 'Trying getting data from database')
        try:
            user = fetch_as_dicts("SELECT * FROM users WHERE id = ?", (message.from_user.id,))[0]
            log(message.from_user.id, 'Data was successfully got')
            order_code = SQLmake(
                'INSERT INTO orders (customerID, date, ifSended, TTN) VALUES (?, ?, ?, ?)',
                (tempOrder["customerID"], tempOrder["date"], False, "")
            )
            log(message.from_user.id, f'Order data was written to database. Order code - {order_code} was successfully got')
            log(message.from_user.id, 'Trying write orderTovarList to database')
            for i in tempOrder["orderTovarList"]:
                order_code = SQLmake(
                    'INSERT INTO order_items (code, art, prop, count) VALUES (?, ?, ?, ?)',
                    (order_code, i["art"], i["prop"], i["count"]))
                try:
                    SQLmake("UPDATE product_properties SET availability = availability - ?  WHERE art = ?  AND property=?", (i["count"],i["art"], i["prop"]))
                except Exception as e:
                    log(message.from_user.id, f"[ERROR] Failed to update availability for {order_code}: {e}")
            log(message.from_user.id, 'orderTovarList was written to database')

            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            markup.add(types.KeyboardButton("üõçÔ∏è–ó—Ä–æ–±–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è"))
            markup.add(types.KeyboardButton("üõí–ú–æ—ó –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è"))
            markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"))

            szResultMessage = (
                "‚úÖ<b>–ó–∞–º–æ–≤–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –æ–±—Ä–æ–±–∫—É.</b>\n\n"
                "–©–æ–¥–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –≤–∞–º –Ω–∞–ø–∏—à—É—Ç—å –ø—Ä–æ—Ç—è–≥–æ–º –¥–Ω—è.\n\n"
                "<b>üíõ–î—è–∫—É—î–º–æ, —â–æ –≤–∏–±—Ä–∞–ª–∏ –Ω–∞—Å!üíõ</b>"
            )

            bot.send_message(message.chat.id, szResultMessage, reply_markup=markup, parse_mode='HTML')

            try:
                log(message.from_user.id, 'Trying send notification to manager')
                adminChat = bot.get_chat(config["adminIDs"][0])
                log(message.from_user.id, f"Manager id: {config["adminIDs"][0]}")
                username = bot.get_chat(message.from_user.id).username
                user = fetch_as_dicts("SELECT * FROM users WHERE id = ?", (message.from_user.id,))[0]
                szResultMessage = f'‚Äº–ù–û–í–ï –ó–ê–ú–û–í–õ–ï–ù–ù–Ø –í–Ü–î –ö–û–†–ò–°–¢–£–í–ê–ß–ê <a href="https://t.me/{username}">{username}</a>‚Äº\n\n'
                szResultMessage += f'''<b>–ó–ê–ú–û–í–õ–ï–ù–ù–Ø ‚Ññ{order_code}</b>
    üìÖ–î–∞—Ç–∞: {tempOrder["date"]}\n
    üîó–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á: <a href="https://t.me/{username}">{username}</a>
        üôé‚Äç‚ôÇÔ∏è–ü–Ü–ë: {user["PIB"]}
        üìû–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É: {user["phone"]}
        üè†–ê–¥—Ä–µ—Å–∞: {user["address"]}\n
    üìÉ–°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫:\n'''
                for tovar in tempOrder["orderTovarList"]:
                    szResultMessage += f'\t\t\t\t\t\t\t\t‚ö´{tovar["art"]}:{tovar["prop"]} - {tovar["count"]}\n'
                bot.send_message(
                    adminChat.id,
                    szResultMessage,
                    parse_mode='HTML'
                )
                log(message.from_user.id, "Notification was sent to manager")
            except Exception as e:
                adminChat = bot.get_chat(config["adminIDs"][0])
                log(message.from_user.id, f"[ERROR] Can`t send notification about order to manager: {e}")
                bot.send_message(
                    adminChat.id,
                    f"–ß–µ—Ä–µ–∑ –ø–æ–º–∏–ª–∫—É –Ω–µ –º–æ–∂—É –≤—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è. –ü–µ—Ä–µ–ø—Ä–æ–≤—ñ—Ä—Ç–µ —Å–ø–∏—Å–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω—å. –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á = {username}",
                    parse_mode='HTML'
                )
            tempOrder = {"customerID": "", "date": "", "ifSended": False, "TTN": "", "orderTovarList": []}
            log(message.from_user.id, "tempOrder reset after saving")
        except Exception as e:
            log(message.from_user.id, f"[ERROR] Failed to save order: {e}")
            msg = bot.send_message(
                message.chat.id,
                "–î–∞–≤–∞–π—Ç–µ –∑–±–µ—Ä–µ–º–æ –≤–∞—à—ñ –¥–∞–Ω—ñ –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏. <b>–í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ –ü–Ü–ë:</b>",
                parse_mode='HTML',
                reply_markup=types.ReplyKeyboardMarkup(resize_keyboard=True).add(types.KeyboardButton("üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"))
            )
            bot.register_next_step_handler(msg, get_PIB)

def get_PIB(message):
    global tempUser, tempOrder
    log(message.from_user.id, "get_PIB called")
    if message.text in ["üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É", "/start"]:
        tempOrder = {"customerID": "", "date": "", "ifSended": False, "TTN": "", "orderTovarList": []}
        tempUser = {"id": 0, "PIB": "", "phone": "", "address": ""}
        back_to_main(message)
        return

    if not has_emoji(message.text):
        tempUser["id"] = message.from_user.id
        tempUser["PIB"] = message.text
        msg = bot.send_message(message.chat.id, "–í–≤–µ–¥—ñ—Ç—å –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É:", parse_mode='HTML')
        bot.register_next_step_handler(msg, get_phone)
    else:
        msg = bot.send_message(message.chat.id, "–í–≤–µ–¥—ñ—Ç—å —â–µ —Ä–∞–∑ –≤–∞—à–µ –ü–Ü–ë –±–µ–∑ –µ–º–æ–¥–∑—ñ:", parse_mode='HTML')
        bot.register_next_step_handler(msg, get_PIB)

def get_phone(message):
    global tempUser, tempOrder

    log(message.from_user.id, "get_phone called")
    if message.text in ["üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É", "/start"]:
        log(message.from_user.id, '"To main page" button pressed')
        tempOrder = {"customerID": "", "date": "", "ifSended": False, "TTN": "", "orderTovarList": []}
        tempUser = {"id": 0, "PIB": "", "phone": "", "address": ""}
        back_to_main(message)
        return

    if has_emoji(message.text):
        log(message.from_user.id, '[ERROR] Message with phone number has emoji. Asking to re-enter number')
        msg = bot.send_message(message.chat.id, "–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –≤–≤–µ–¥–µ–Ω–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –í–≤–µ–¥—ñ—Ç—å –≤–∞—à –Ω–æ–º–µ—Ä —â–µ —Ä–∞–∑, –±—É–¥—å –ª–∞—Å–∫–∞:", parse_mode='HTML')
        bot.register_next_step_handler(msg, get_phone)
        return

    phone = message.text.strip()
    log(message.from_user.id, 'Phone number was got')
    valid = False

    if len(phone) == 10 and phone.startswith("0") and isInt(phone):
        tempUser["phone"] = f"+38{phone}"
        valid = True
    elif len(phone) == 13 and phone.startswith("+") and isInt(phone[1:]):
        tempUser["phone"] = phone
        valid = True
    elif len(phone) == 12 and phone.startswith("3") and isInt(phone):
        tempUser["phone"] = f"+{phone}"
        valid = True

    if valid:
        log(message.from_user.id, 'Phone number was succssefully read')
        msg = bot.send_message(message.chat.id, "–í–≤–µ–¥—ñ—Ç—å –∞–¥—Ä–µ—Å—É –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è:", parse_mode='HTML')
        bot.register_next_step_handler(msg, submit_data_colect)
    else:
        log(message.from_user.id, '[ERROR] Phonr number is not valid. Asking to re-enter number')
        msg = bot.send_message(message.chat.id, "–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –≤–≤–µ–¥–µ–Ω–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑:", parse_mode='HTML')
        bot.register_next_step_handler(msg, get_phone)

def submit_data_colect(message):
    global tempUser, tempOrder
    user_id = message.from_user.id
    log(user_id, "submit_data_colect called")

    if message.text == "üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É":
        log(user_id, '"To main page" button pressed')
        tempOrder = {"customerID": "", "date": "", "ifSended": False, "TTN": "", "orderTovarList": []}
        tempUser = {"id": 0, "PIB": "", "phone": "", "address": ""}
        log(user_id, "tempOrder and tempUser reset due to 'main page' command")
        back_to_main(message)
        return

    if not has_emoji(message.text):
        tempUser["address"] = message.text
        log(user_id, f"Address received: {message.text}")

        try:
            log(user_id, "Attempting to insert user into database")
            SQLmake(
                'INSERT INTO users (id, PIB, phone, address) VALUES (?, ?, ?, ?)',
                (tempUser["id"], tempUser["PIB"], tempUser["phone"], tempUser["address"])
            )
            log(user_id, "User successfully inserted into database")
        except Exception as e:
            log(user_id, f"[ERROR] Failed to insert user: {e}")

        try:
            log(user_id, "Attempting to insert order into database")
            order_code = SQLmake(
                'INSERT INTO orders (customerID, date, ifSended, TTN) VALUES (?, ?, ?, ?)',
                (tempOrder["customerID"], tempOrder["date"], False, "")
            )
            log(user_id, f"Order successfully inserted with code {order_code}")

            for i in tempOrder["orderTovarList"]:
                log(user_id, f"Inserting order item: art={i['art']}, prop={i['prop']}, count={i['count']}")
                order_code = SQLmake(
                    'INSERT INTO order_items (code, art, prop, count) VALUES (?, ?, ?, ?)',
                    (order_code, i["art"], i["prop"], i["count"])
                )
                try:
                    SQLmake("UPDATE product_properties SET availability = availability - ?  WHERE art = ?  AND property=?", (i["count"],i["art"], i["prop"]))
                except Exception as e:
                    log(message.from_user.id, f"[ERROR] Failed to update availability for {order_code}: {e}")
            log(user_id, "All order items successfully inserted")

        except Exception as e:
            log(user_id, f"[ERROR] Failed to insert order or items: {e}")

        szResultMessage = (
            "‚úÖ<b>–í–∞—à–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –æ–±—Ä–æ–±–∫—É.</b>\n\n"
            "–ú–∏ –∑–≤'—è–∂–µ–º–æ—Å—è –∑ –≤–∞–º–∏ —â–æ–¥–æ –¥–æ—Å—Ç–∞–≤–∫–∏ –ø—Ä–æ—Ç—è–≥–æ–º –¥–Ω—è.\n\n"
            "<b>üíõ–î—è–∫—É—î–º–æ, —â–æ –≤–∏–±—Ä–∞–ª–∏ –Ω–∞—Å!üíõ</b>"
        )

        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add(types.KeyboardButton("üõçÔ∏è–ó—Ä–æ–±–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è"))
        markup.add(types.KeyboardButton("üõí–ú–æ—ó –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è"))
        markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"))
        log(user_id, "Sending confirmation message and resetting menu buttons")
        bot.send_message(message.chat.id, szResultMessage, parse_mode='HTML', reply_markup=markup)

        try:
            log(message.from_user.id, 'Trying send notification to manager')
            adminChat = bot.get_chat(config["adminIDs"][0])
            log(message.from_user.id, f"Manager id: {config["adminIDs"][0]}")
            username = bot.get_chat(message.from_user.id).username
            szResultMessage = f'‚Äº–ù–û–í–ï –ó–ê–ú–û–í–õ–ï–ù–ù–Ø –í–Ü–î –ö–û–†–ò–°–¢–£–í–ê–ß–ê <a href="https://t.me/{username}">{username}</a>‚Äº\n'
            szResultMessage += f'''<b>–ó–ê–ú–û–í–õ–ï–ù–ù–Ø ‚Ññ{order_code}</b>
    üìÖ–î–∞—Ç–∞: {tempOrder["date"]}\n
    üîó–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á: <a href="https://t.me/{username}">{username}</a>
        üôé‚Äç‚ôÇÔ∏è–ü–Ü–ë: {tempUser["PIB"]}
        üìû–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É: {tempUser["phone"]}
        üè†–ê–¥—Ä–µ—Å–∞: {tempUser["address"]}\n
    üìÉ–°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫:\n'''
            for tovar in tempOrder["orderTovarList"]:
                szResultMessage += f'\t\t\t\t\t\t\t\t‚ö´{tovar["art"]}:{tovar["prop"]} - {tovar["count"]}\n'
            bot.send_message(
                    adminChat.id,
                    szResultMessage,
                    parse_mode='HTML'
            )
            log(message.from_user.id, "Notification was sent to manager")
        except Exception as e:
            adminChat = bot.get_chat(config["adminIDs"][0])
            bot.send_message(
            adminChat.id,
            f"–ß–µ—Ä–µ–∑ –ø–æ–º–∏–ª–∫—É –Ω–µ –º–æ–∂—É –≤—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è. –ü–µ—Ä–µ–ø—Ä–æ–≤—ñ—Ä—Ç–µ —Å–ø–∏—Å–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω—å. –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á = {username}",
            parse_mode='HTML'
        )
        tempOrder = {"customerID": "", "date": "", "ifSended": False, "TTN": "", "orderTovarList": []}
        tempUser = {"id": 0, "PIB": "", "phone": "", "address": ""}
        log(user_id, "tempOrder and tempUser reset after saving")
    else:
        log(user_id, f"[ERROR] Address contains emoji: {message.text}")
        msg = bot.send_message(message.chat.id, "–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∞–¥—Ä–µ—Å—É —â–µ —Ä–∞–∑ –±–µ–∑ –µ–º–æ–¥–∑—ñ:", parse_mode='HTML')
        log(user_id, "Asking user to re-enter address without emoji")
        bot.register_next_step_handler(msg, submit_data_colect)

# ================ USER MESSAGE HANDLERS ================
@bot.message_handler(commands=['start'])
def start(message):
    try:
        log(message.from_user.id, '"/start" command received')
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add(types.KeyboardButton("üõçÔ∏è–ó—Ä–æ–±–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è"))
        markup.add(types.KeyboardButton("üõí–ú–æ—ó –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è"))
        markup.add(types.KeyboardButton("‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"))
        log(message.from_user.id, "Main menu buttons created")
        bot.send_message(message.chat.id, "üëã–í—ñ—Ç–∞—î–º–æ! –û–±–µ—Ä—ñ—Ç—å –æ–ø—Ü—ñ—é:", reply_markup=markup)
        log(message.from_user.id, "Main menu message sent")
    except Exception as e:
        log(message.from_user.id, f"[ERROR] start(): {e}")


@bot.message_handler(func=lambda message: message.text == "üõí–ú–æ—ó –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è")
def my_orders(message):
    try:
        log(message.from_user.id, '"My orders" button pressed')
        orderList = fetch_as_dicts("SELECT * FROM orders WHERE customerID = ?", (int(message.from_user.id),))
        log(message.from_user.id, f"{len(orderList)} orders fetched from database")
        if orderList:
            szResultMessage = f'\t<b>üßæ –ú–û–á –ó–ê–ú–û–í–õ–ï–ù–ù–Ø</b>\n'
            for order in orderList:
                log(message.from_user.id, f"Processing order #{order['code']}")
                szResultMessage += f'''
<b>üì¶ –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è ‚Ññ{order["code"]}</b>
    üìÖ <b>–î–∞—Ç–∞:</b> {order["date"]}
    üì© <b>–í—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ:</b> {"‚úÖ –¢–∞–∫" if order["ifSended"] else "‚ùå –ù—ñ"}
        üî¢ <b>–¢–¢–ù:</b> {order["TTN"]}
    üõçÔ∏è <b>–°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫:</b>\n'''
                orderTovarList = fetch_as_dicts("SELECT * FROM order_items WHERE code = ?", (int(order["code"]),))
                log(message.from_user.id, f"{len(orderTovarList)} items found for order #{order['code']}")
                for tovar in orderTovarList:
                    szResultMessage += f'\t\t\t\t\t\t ‚Ä¢üõí <b>{tovar["art"]}</b>: {tovar["prop"]} ‚Äî {tovar["count"]} —à—Ç.\n'
            bot.send_message(message.chat.id, szResultMessage, parse_mode='HTML')
            log(message.from_user.id, "Order list sent to user")
        else:
            log(message.from_user.id, f"User has no orders")
            bot.send_message(message.chat.id, "–ù–∞—Ä–∞–∑—ñ —É –≤–∞—Å –≤—ñ–¥—Å—É—Ç–Ω—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è", parse_mode='HTML')
    except Exception as e:
        log(message.from_user.id, f"[ERROR] my_orders(): {e}")
        bot.send_message(message.chat.id, "–ù–∞—Ä–∞–∑—ñ —É –≤–∞—Å –≤—ñ–¥—Å—É—Ç–Ω—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è", parse_mode='HTML')


@bot.message_handler(func=lambda message: message.text == "üõçÔ∏è–ó—Ä–æ–±–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è")
def make_order(message):
    try:
        global tempOrder
        log(message.from_user.id, '"Make order" button pressed')

        tempOrder = {
            "customerID": message.from_user.id,
            "date": datetime.now().strftime("%H:%M %d.%m.%Y"),
            "ifSended": False,
            "TTN": "",
            "orderTovarList": []
        }
        log(message.from_user.id, f'tempOrder initialized: {tempOrder}')

        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        row = []
        DataList = fetch_as_dicts("SELECT * FROM products")
        log(message.from_user.id, f"{len(DataList)} products loaded from database")

        for idx, item in enumerate(DataList):
            row.append(types.KeyboardButton(item["art"]))
            if (idx + 1) % 3 == 0:
                markup.row(*row)
                row = []
        if row:
            markup.row(*row)
        log(message.from_user.id, "Product buttons added to markup")

        msgText = (
            "ü§î <b>–û–±–µ—Ä—ñ—Ç—å —Ç–æ–≤–∞—Ä</b> –∑–∞ –∞—Ä—Ç–∏–∫—É–ª–æ–º –∞–±–æ –ø—Ä–æ—Å—Ç–æ <b>–ø–µ—Ä–µ—à–ª—ñ—Ç—å</b> –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ –Ω–∞—à–æ–≥–æ –∫–∞–Ω–∞–ª—É üì®\n\n"
            "üÜî –ù–∞–∂–º—ñ—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É –∑ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–º –∞—Ä—Ç–∏–∫—É–ª–æ–º\n\n\t\t–∞–±–æ\n\n"
            "üì≤ –ü–µ—Ä–µ—à–ª—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä—è–º–æ —Å—é–¥–∏ ‚Äî —ñ —è –≤—Å–µ –æ–±—Ä–æ–±–ª—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ!"
        )
        msg = bot.send_message(message.chat.id, msgText, reply_markup=markup, parse_mode='HTML')
        log(message.from_user.id, "Product selection message sent")
        bot.register_next_step_handler(msg, ifThisCorrectTovar)
        log(message.from_user.id, "Next step handler registered for product selection")
    except Exception as e:
        log(message.from_user.id, f"[ERROR] make_order(): {e}")
        bot.send_message(message.chat.id, "‚ö† –°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ—á–∞—Ç–∫—É –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è")


@bot.message_handler(func=lambda message: message.text == "‚úâ–ó–≤'—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º")
def contact_to_manager(message):
    try:
        log(message.from_user.id, '"Contact to manager" button pressed')
        adminChat = bot.get_chat(config["adminIDs"][0])
        username = bot.get_chat(message.from_user.id).username
        log(message.from_user.id, f"User username resolved: {username}")

        bot.send_message(
            adminChat.id,
            f'‚Äº‚Äº–ó–∞–ø–∏—Ç –Ω–∞ –∑–≤–æ—Ä–æ—Ç–Ω—ñ–π –∑–≤\'—è–∑–æ–∫ –∑ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º <a href="https://t.me/{username}">{username}</a>‚Äº‚Äº',
            parse_mode='HTML'
        )
        log(message.from_user.id, "Contact request sent to admin")

        msg = (
            "üßæ <b>–í–∞—à–µ –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è –ø—Ä–∏–π–Ω—è—Ç–æ!</b>\n\n"
            "–ù–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –∑–≤ º—è–∂–µ—Ç—å—Å—è –∑ –≤–∞–º–∏ –Ω–∞–π–±–ª–∏–∂—á–∏–º —á–∞—Å–æ–º –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–Ω—è –¥–µ—Ç–∞–ª–µ–π.\n"
            "–Ø–∫—â–æ —É –≤–∞—Å —î –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–∏—Ç–∞–Ω–Ω—è ‚Äî –Ω–µ —Å–æ—Ä–æ–º—Ç–µ—Å—è –Ω–∞–ø–∏—Å–∞—Ç–∏ –Ω–∞–ø—Ä—è–º—É.\n\n"
            f"üìû <b>–ö–æ–Ω—Ç–∞–∫—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞:</b> üßì <a href=\"tg://user?id={config['adminIDs'][0]}\">–ú–µ–Ω–µ–¥–∂–µ—Ä</a>\n\n"
            "üì¶ –î—è–∫—É—î–º–æ, —â–æ –æ–±—Ä–∞–ª–∏ –Ω–∞—Å! –ú–∏ –∑–∞–≤–∂–¥–∏ –≥–æ—Ç–æ–≤—ñ –¥–æ–ø–æ–º–æ–≥—Ç–∏ ü§ù"
        )
        bot.send_message(message.chat.id, msg, parse_mode='HTML')
        log(message.from_user.id, "Confirmation message sent to user")
    except Exception as e:
        log(message.from_user.id, f"[ERROR] contact_to_manager(): {e}")
        bot.send_message(message.chat.id, "‚ö† –ù–µ –≤–¥–∞–ª–æ—Å—è –∑–≤ º—è–∑–∞—Ç–∏—Å—è –∑ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º")


@bot.message_handler(func=lambda message: message.text == "üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É")
def back_to_main(message):
    try:
        log(message.from_user.id, '"To main page" button pressed')
        start(message)
        log(message.from_user.id, "start() called from back_to_main")
    except Exception as e:
        log(message.from_user.id, f"[ERROR] back_to_main(): {e}")
        bot.send_message(message.chat.id, "‚ö† –ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å –Ω–∞ –≥–æ–ª–æ–≤–Ω—É —Å—Ç–æ—Ä—ñ–Ω–∫—É")



# ================ ADMIN COMMANDS ================
@bot.message_handler(commands=['start_sending'])
def start_sending(message):
    global scheduler_running
    if message.from_user.id in config["adminIDs"]:
        scheduler_running = True
        log_sys('Scheduler started by admin')
        log(message.from_user.id, 'Command /start_sending used')
        bot.send_message(message.chat.id, "–†–æ–∑—Å–∏–ª–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞üèÉ‚Äç‚ôÄÔ∏è")

@bot.message_handler(commands=['stop_sending'])
def stop_sending(message):
    global scheduler_running
    if message.from_user.id in config["adminIDs"]:
        scheduler_running = False
        log_sys('Scheduler stopped by admin')
        log(message.from_user.id, 'Command /stop_sending used')
        bot.send_message(message.chat.id, "–†–æ–∑—Å–∏–ª–∫–∞ –∑—É–ø–∏–Ω–µ–Ω–∞‚õî")


@bot.message_handler(commands=['orderlist'])
def send_orderlist1(message):
    if message.from_user.id in config["adminIDs"]:
        log(message.from_user.id, 'Command /orderlist used')
        szResultMessage = "üìÉ–°–ø–∏—Å–æ–∫ –∑–∞–º–æ–≤–ª–µ–Ω—å:\n"
        try:
            orderList = fetch_as_dicts("SELECT * FROM orders")
            log(message.from_user.id, f'{len(orderList)} orders fetched from database')
        except Exception as e:
            orderList = []
            log(message.from_user.id, f'[ERROR] Failed to fetch orders: {e}')

        if orderList:
            for order in orderList:
                try:
                    username = bot.get_chat(order["customerID"]).username
                except:
                    username = "Unknown"
                ifSended = "–í—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ‚úÖ" if order["ifSended"] else "–ù–ï –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ‚ùå"
                szResultMessage += f'{order["code"]}. <a href="tg://user?id={order["customerID"]}">{username}</a> : {ifSended}\n'

            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            row = []
            for idx, order in enumerate(orderList):
                row.append(types.KeyboardButton(order["code"]))
                if (idx + 1) % 3 == 0:
                    markup.row(*row)
                    row = []
            if row:
                markup.row(*row)
            log(message.from_user.id, 'Order list buttons generated')
            msg = bot.send_message(message.chat.id, szResultMessage, parse_mode='HTML', reply_markup=markup)
            log(message.from_user.id, 'Order list message sent')
            bot.register_next_step_handler(msg, send_orderlist2)
        else:
            log(message.from_user.id, 'No orders found')
            bot.send_message(message.chat.id, "–ù–∞—Ä–∞–∑—ñ –Ω–µ–º–∞ –∑–∞–º–æ–≤–ª–µ–Ω—å", parse_mode='HTML')


def send_orderlist2(message):
    global currOrderCode
    if message.text in ["/start", "üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"]:
        log(message.from_user.id, '"To main page" button pressed')
        start(message)
        return
    try:
        log(message.from_user.id, f'Requested order #{message.text}')
        order = fetch_as_dicts(f"SELECT * FROM orders WHERE code = {int(message.text)}")[0]
        order["orderTovarList"] = fetch_as_dicts(f"SELECT * FROM order_items WHERE code = {int(order['code'])}")
        currOrderCode = int(order['code'])
        log(message.from_user.id, f'Order #{currOrderCode} details loaded')

        currUser = fetch_as_dicts(f"SELECT * FROM users WHERE id = {order['customerID']}")[0]
        username = bot.get_chat(order["customerID"]).username

        szResultMessage = f'''\t<b>–ó–ê–ú–û–í–õ–ï–ù–ù–Ø ‚Ññ{order["code"]}</b>
üìÖ–î–∞—Ç–∞: {order["date"]}\n
üîó–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á: <a href="tg://user?id={order["customerID"]}">{username}</a>
    üôé‚Äç‚ôÇÔ∏è–ü–Ü–ë: {currUser["PIB"]}
    üìû–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É: {currUser["phone"]}
    üè†–ê–¥—Ä–µ—Å–∞: {currUser["address"]}\n
üî¢–¢–¢–ù: {order["TTN"]}
üì©–í—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ: {"–¢–∞–∫" if order["ifSended"] else "–ù—ñ"}\n
üìÉ–°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫:\n'''
        for tovar in order["orderTovarList"]:
            szResultMessage += f'\t\t‚ö´{tovar["art"]}:{tovar["prop"]} - {tovar["count"]}\n'

        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        if order["ifSended"]:
            markup.add(types.KeyboardButton("–ó–º—ñ–Ω–∏—Ç–∏ –¢–¢–ù"))
        else:
            markup.add(types.KeyboardButton("–î–æ–¥–∞—Ç–∏ –¢–¢–ù"))
        markup.add(types.KeyboardButton("‚¨Ö–ù–∞–∑–∞–¥"))

        msg = bot.send_message(message.chat.id, szResultMessage, parse_mode='HTML', reply_markup=markup)
        log(message.from_user.id, f'Detailed order #{currOrderCode} message sent')
        bot.register_next_step_handler(msg, send_orderlist3)
    except Exception as e:
        log(message.from_user.id, f'[ERROR] Failed in send_orderlist2: {e}')


def send_orderlist3(message):
    global currOrderCode
    if message.text == "‚¨Ö–ù–∞–∑–∞–¥":
        log(message.from_user.id, 'Back button pressed in order detail view')
        send_orderlist1(message)
    elif message.text in ["/start", "üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"]:
        log(message.from_user.id, '"To main page" button pressed')
        start(message)
        return
    elif message.text in ["–î–æ–¥–∞—Ç–∏ –¢–¢–ù", "–ó–º—ñ–Ω–∏—Ç–∏ –¢–¢–ù"]:
        log(message.from_user.id, 'Requesting TTN input')
        msg = bot.send_message(message.chat.id, "üî¢–í–≤–µ–¥—ñ—Ç—å –¢–¢–ù", parse_mode='HTML')
        bot.register_next_step_handler(msg, add_TTN)



def add_TTN(message):
    if message.text in ["/start", "üè†–ù–∞ –≥–æ–ª–æ–≤–Ω—É"]:
        log(message.from_user.id, '"To main page" button pressed')
        start(message)
        return
    try:
        log(message.from_user.id, f'Updating TTN for order #{currOrderCode} to "{message.text}"')
        SQLmake("UPDATE orders SET TTN = ?, ifSended = ? WHERE code = ?", (message.text, 1, currOrderCode))
        log(message.from_user.id, f'TTN updated successfully for order #{currOrderCode}')
        send_orderlist1(message)
    except Exception as e:
        log(message.from_user.id, f'[ERROR] Failed to update TTN: {e}')


@bot.message_handler(commands=['recheckstatus'])
def reCheckStatus(message):
    try:
        log(message.from_user.id, 'Command /recheckstatus used')
        DataList = fetch_as_dicts("SELECT code, frontImage, backImage FROM orders")
        log(message.from_user.id, f'{len(DataList)} orders fetched for status recheck')

        for data in DataList:
            if len(data["frontImage"]) < 2 and len(data["backImage"]) < 2:
                SQLmake("UPDATE orders SET active = 0 WHERE code = ?", (data['code'],))
                log(message.from_user.id, f'Order #{data["code"]} marked inactive')
            else:
                SQLmake("UPDATE orders SET active = 1 WHERE code = ?", (data['code'],))
                log(message.from_user.id, f'Order #{data["code"]} marked active')
        bot.send_message(message.chat.id, "–°—Ç–∞—Ç—É—Å–∏ —Ç–æ–≤–∞—Ä—ñ–≤ –±—É–ª–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω—ñ")
        log(message.from_user.id, 'Order statuses rechecked and message sent')
    except Exception as e:
        log_sys(f"[ERROR] Failed in reCheckStatus: {e}")

# ================ SCHEDULER ================

def formMessageText(data, user_id):
    try:
        name = data.get('name', '‚öΩ –§–æ—Ä–º–∞')
        art = data.get('art', '---')
        log(user_id, f'Start forming message for article: {art}')

        about = data.get('about', '').strip()
        if not about:
            log(user_id, f'Description not found for {art}, auto-generating')
            if "—Ñ–æ—Ä–º–∞" in name.lower():
                brand = ""
                player = ""
                for word in ["ronaldo","messi", "mbappe", "mudryk", "dovbyk"]:
                    if word in name.lower():
                        player = word.capitalize()
                for word in ["nike", "adidas", "puma", "select", "umbro"]:
                    if word in name.lower():
                        brand = word.capitalize()
                if brand and player:
                    abouts = [f"üëï –î–∏—Ç—è—á–∞ —Ñ—É—Ç–±–æ–ª—å–Ω–∞ —Ñ–æ—Ä–º–∞ {brand} {player} ‚Äî –∫–æ–º–ø–ª–µ–∫—Ç –∑ —Ñ—É—Ç–±–æ–ª–∫–∏ —Ç–∞ —à–æ—Ä—Ç—ñ–≤ —É —Å—Ç–∏–ª—ñ {player}.\n\t‚Ä¢ –î–∏—Ö–∞—é—á–∞ —Ç–∫–∞–Ω–∏–Ω–∞\n\t‚Ä¢ –ü—Ä–∏–Ω—Ç ‚Äú{player}‚Äù\n\t‚Ä¢ –ü—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Ç—Ä–µ–Ω—É–≤–∞–Ω—å, —ñ–≥–æ—Ä —ñ –ø–æ–≤—Å—è–∫–¥–µ–Ω–Ω–æ–≥–æ –Ω–æ—Å—ñ–Ω–Ω—è\n–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ –¥–ª—è –¥—ñ—Ç–µ–π –≤—ñ–∫–æ–º 5‚Äì16 —Ä–æ–∫—ñ–≤.",
                        f"‚öΩÔ∏è –ö–æ–º–ø–ª–µ–∫—Ç –¥–∏—Ç—è—á–æ—ó —Ñ–æ—Ä–º–∏ {brand} {player} ‚Äî —ñ–¥–µ–∞–ª—å–Ω–∏–π –≤–∏–±—ñ—Ä –¥–ª—è –∞–∫—Ç–∏–≤–Ω–∏—Ö –¥—ñ—Ç–µ–π.\n\t‚Ä¢ –í–∏—Å–æ–∫–æ—è–∫—ñ—Å–Ω–∏–π –ø–æ–ª—ñ–µ—Å—Ç–µ—Ä, –ø—Ä–∏—î–º–Ω–∏–π –¥–æ —Ç—ñ–ª–∞\n\t‚Ä¢ –Ø—Å–∫—Ä–∞–≤–∏–π –¥–∏–∑–∞–π–Ω —É —Å—Ç–∏–ª—ñ {player}\n\t‚Ä¢ –§—É—Ç–±–æ–ª–∫–∞ + —à–æ—Ä—Ç–∏, –µ–ª–∞—Å—Ç–∏—á–Ω–∏–π –ø–æ—è—Å\n–§–æ—Ä–º–∞ –Ω–µ —Å–∫–æ–≤—É—î —Ä—É—Ö—ñ–≤ —ñ –ª–µ–≥–∫–æ –ø–µ—Ä–µ—Ç—å—Å—è.",
                        f"üì¶ –£ –∫–æ–º–ø–ª–µ–∫—Ç—ñ: —Ñ—É—Ç–±–æ–ª–∫–∞ —Ç–∞ —à–æ—Ä—Ç–∏ {brand} {player}\n\t‚Ä¢ –°—Ç–∏–ª—å–Ω–∞ —Ä–µ–ø–ª—ñ–∫–∞ –∑ —ñ–º–µ–Ω–µ–º —Ç–∞ –Ω–æ–º–µ—Ä–æ–º –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ–≥–æ –≥—Ä–∞–≤—Ü—è\n\t‚Ä¢ –í–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∞ –∑ –ª–µ–≥–∫–æ–≥–æ, –¥–∏—Ö–∞—é—á–æ–≥–æ –º–∞—Ç–µ—Ä—ñ–∞–ª—É\n\t‚Ä¢ –î–æ–±—Ä–µ –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Ñ—É—Ç–±–æ–ª—å–Ω–∏—Ö —Å–µ–∫—Ü—ñ–π —ñ –≥—Ä–∏ –Ω–∞ –≤—É–ª–∏—Ü—ñ\n–î–æ—Å—Ç—É–ø–Ω–∞ –≤ —Ä—ñ–∑–Ω–∏—Ö —Ä–æ–∑–º—ñ—Ä–∞—Ö –¥–ª—è –¥—ñ—Ç–µ–π —Ä—ñ–∑–Ω–æ–≥–æ –≤—ñ–∫—É."]
                elif brand:
                    abouts = [f"üëï –î–∏—Ç—è—á–∞ —Ñ—É—Ç–±–æ–ª—å–Ω–∞ —Ñ–æ—Ä–º–∞ {brand} ‚Äî –∫–æ–º–ø–ª–µ–∫—Ç –∑ —Ñ—É—Ç–±–æ–ª–∫–∏ —Ç–∞ —à–æ—Ä—Ç—ñ–≤.\n\t‚Ä¢ –î–∏—Ö–∞—é—á–∞ —Ç–∫–∞–Ω–∏–Ω–∞\n\t‚Ä¢ –ü—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Ç—Ä–µ–Ω—É–≤–∞–Ω—å, —ñ–≥–æ—Ä —ñ –ø–æ–≤—Å—è–∫–¥–µ–Ω–Ω–æ–≥–æ –Ω–æ—Å—ñ–Ω–Ω—è\n–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ –¥–ª—è –¥—ñ—Ç–µ–π –≤—ñ–∫–æ–º 5‚Äì16 —Ä–æ–∫—ñ–≤.",
                         f"‚öΩÔ∏è –ö–æ–º–ø–ª–µ–∫—Ç –¥–∏—Ç—è—á–æ—ó —Ñ–æ—Ä–º–∏ {brand} ‚Äî —ñ–¥–µ–∞–ª—å–Ω–∏–π –≤–∏–±—ñ—Ä –¥–ª—è –∞–∫—Ç–∏–≤–Ω–∏—Ö –¥—ñ—Ç–µ–π.\n\t‚Ä¢ –í–∏—Å–æ–∫–æ—è–∫—ñ—Å–Ω–∏–π –ø–æ–ª—ñ–µ—Å—Ç–µ—Ä, –ø—Ä–∏—î–º–Ω–∏–π –¥–æ —Ç—ñ–ª–∞\n\t‚Ä¢ –§—É—Ç–±–æ–ª–∫–∞ + —à–æ—Ä—Ç–∏, –µ–ª–∞—Å—Ç–∏—á–Ω–∏–π –ø–æ—è—Å\n–§–æ—Ä–º–∞ –Ω–µ —Å–∫–æ–≤—É—î —Ä—É—Ö—ñ–≤ —ñ –ª–µ–≥–∫–æ –ø–µ—Ä–µ—Ç—å—Å—è.",
                         f"üì¶ –£ –∫–æ–º–ø–ª–µ–∫—Ç—ñ: —Ñ—É—Ç–±–æ–ª–∫–∞ —Ç–∞ —à–æ—Ä—Ç–∏ {brand}\n\t‚Ä¢ –°—Ç–∏–ª—å–Ω–∞ —Ä–µ–ø–ª—ñ–∫–∞ –∑ —ñ–º–µ–Ω–µ–º —Ç–∞ –Ω–æ–º–µ—Ä–æ–º –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ–≥–æ –≥—Ä–∞–≤—Ü—è\n\t‚Ä¢ –í–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∞ –∑ –ª–µ–≥–∫–æ–≥–æ, –¥–∏—Ö–∞—é—á–æ–≥–æ –º–∞—Ç–µ—Ä—ñ–∞–ª—É\n\t‚Ä¢ –î–æ–±—Ä–µ –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Ñ—É—Ç–±–æ–ª—å–Ω–∏—Ö —Å–µ–∫—Ü—ñ–π —ñ –≥—Ä–∏ –Ω–∞ –≤—É–ª–∏—Ü—ñ\n–î–æ—Å—Ç—É–ø–Ω–∞ –≤ —Ä—ñ–∑–Ω–∏—Ö —Ä–æ–∑–º—ñ—Ä–∞—Ö –¥–ª—è –¥—ñ—Ç–µ–π —Ä—ñ–∑–Ω–æ–≥–æ –≤—ñ–∫—É."]
                elif player:
                    abouts = [f"üëï –î–∏—Ç—è—á–∞ —Ñ—É—Ç–±–æ–ª—å–Ω–∞ —Ñ–æ—Ä–º–∞ —É —Å—Ç–∏–ª—ñ {player}.\n\t‚Ä¢ –î–∏—Ö–∞—é—á–∞ —Ç–∫–∞–Ω–∏–Ω–∞\n\t‚Ä¢ –ü—Ä–∏–Ω—Ç ‚Äú{player}‚Äù\n\t‚Ä¢ –ü—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Ç—Ä–µ–Ω—É–≤–∞–Ω—å, —ñ–≥–æ—Ä —ñ –ø–æ–≤—Å—è–∫–¥–µ–Ω–Ω–æ–≥–æ –Ω–æ—Å—ñ–Ω–Ω—è\n–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ –¥–ª—è –¥—ñ—Ç–µ–π –≤—ñ–∫–æ–º 5‚Äì16 —Ä–æ–∫—ñ–≤.",
                             f"‚öΩÔ∏è –ö–æ–º–ø–ª–µ–∫—Ç –¥–∏—Ç—è—á–æ—ó —Ñ–æ—Ä–º–∏ {player} ‚Äî —ñ–¥–µ–∞–ª—å–Ω–∏–π –≤–∏–±—ñ—Ä –¥–ª—è –∞–∫—Ç–∏–≤–Ω–∏—Ö –¥—ñ—Ç–µ–π.\n\t‚Ä¢ –í–∏—Å–æ–∫–æ—è–∫—ñ—Å–Ω–∏–π –ø–æ–ª—ñ–µ—Å—Ç–µ—Ä, –ø—Ä–∏—î–º–Ω–∏–π –¥–æ —Ç—ñ–ª–∞\n\t‚Ä¢ –Ø—Å–∫—Ä–∞–≤–∏–π –¥–∏–∑–∞–π–Ω —É —Å—Ç–∏–ª—ñ {player}\n\t‚Ä¢ –§—É—Ç–±–æ–ª–∫–∞ + —à–æ—Ä—Ç–∏, –µ–ª–∞—Å—Ç–∏—á–Ω–∏–π –ø–æ—è—Å\n–§–æ—Ä–º–∞ –Ω–µ —Å–∫–æ–≤—É—î —Ä—É—Ö—ñ–≤ —ñ –ª–µ–≥–∫–æ –ø–µ—Ä–µ—Ç—å—Å—è.",
                             f"üì¶ –£ –∫–æ–º–ø–ª–µ–∫—Ç—ñ: —Ñ—É—Ç–±–æ–ª–∫–∞ —Ç–∞ —à–æ—Ä—Ç–∏ {player}\n\t‚Ä¢ –°—Ç–∏–ª—å–Ω–∞ —Ä–µ–ø–ª—ñ–∫–∞ –∑ —ñ–º–µ–Ω–µ–º —Ç–∞ –Ω–æ–º–µ—Ä–æ–º –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ–≥–æ –≥—Ä–∞–≤—Ü—è\n\t‚Ä¢ –í–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∞ –∑ –ª–µ–≥–∫–æ–≥–æ, –¥–∏—Ö–∞—é—á–æ–≥–æ –º–∞—Ç–µ—Ä—ñ–∞–ª—É\n\t‚Ä¢ –î–æ–±—Ä–µ –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Ñ—É—Ç–±–æ–ª—å–Ω–∏—Ö —Å–µ–∫—Ü—ñ–π —ñ –≥—Ä–∏ –Ω–∞ –≤—É–ª–∏—Ü—ñ\n–î–æ—Å—Ç—É–ø–Ω–∞ –≤ —Ä—ñ–∑–Ω–∏—Ö —Ä–æ–∑–º—ñ—Ä–∞—Ö –¥–ª—è –¥—ñ—Ç–µ–π —Ä—ñ–∑–Ω–æ–≥–æ –≤—ñ–∫—É."]
                else:
                    abouts = [(
                        "‚óªÔ∏è–ú–∞—Ç–µ—Ä—ñ–∞–ª: –ø–æ–ª—ñ–µ—Å—Ç–µ—Ä ‚Äì –¥–∏—Ö–∞—é—á–∏–π —Ç–∞ –ø—Ä–∏—î–º–Ω–∏–π –¥–æ —Ç—ñ–ª–∞\n"
                        "‚óªÔ∏è–†—É–∫–∞–≤: –∫–æ—Ä–æ—Ç–∫–∏–π\n"
                        "‚óªÔ∏è–ö–æ–ª—ñ—Ä: –¥–∏–≤. —Ñ–æ—Ç–æ"
                    )]
                about=""
                temp = abouts[0]
                if len(abouts) == 1:
                    about = abouts[0]
                else:
                    about = random.choice(abouts)
                    while about == temp:
                        about = random.choice(abouts)

        props = ""
        for prop in list(data['availabilityForProperties'].keys()):
            if prop.lower() != "null" and prop.strip():
                if data['availabilityForProperties'][prop] != 0:
                    props += f"‚¨õÔ∏è {prop.strip()}\n"
        if not props:
            log(user_id, f'{art} is unavailable')
            props = "–ù–µ–º–∞—î –≤ –Ω–∞—è–≤–Ω–æ—Å—Ç—ñ"
        else:
            log(user_id, f'{art} availability parsed')

        priceForProperties = data['priceForProperties']
        price_list = list(set(priceForProperties.values()))
        if len(price_list) == 1:
            price_str = f"{price_list[0]} –≥—Ä–Ω"
        elif price_list:
            try:
                min_price = min([int(p) for p in price_list if str(p).isdigit()])
                price_str = f"–≤—ñ–¥ {min_price} –≥—Ä–Ω"
            except:
                log(user_id, f'{art} contains non-digit prices')
                price_str = "–¶—ñ–Ω—É —É—Ç–æ—á–Ω—é–π—Ç–µ"
        else:
            log(user_id, f'{art} has no prices for properties')
            price_str = "–¶—ñ–Ω—É —É—Ç–æ—á–Ω—é–π—Ç–µ"

        hashtags = {"#—Ñ–æ—Ä–º–∞"}
        name_lower = name.lower()
        for word, tag in [
            ("ronaldo", "#ronaldo"),
            ("messi", "#messi"),
            ("mbappe", "#mbappe"),
            ("mudryk", "#mudryk"),
            ("dovbyk", "#dovbyk"),
            ("nike", "#nike"),
            ("adidas", "#adidas"),
            ("puma", "#puma"),
            ("select", "#select"),
            ("umbro", "#umbro"),
        ]:
            if word in name_lower:
                hashtags.add(tag)
        hashtag_str = ' '.join(hashtags)
        log(user_id, f'Hashtags set for {art}: {hashtag_str}')

        szResultMessage = (
            f"üî•<b>{name}</b>üî•\n\n"
            f"–ê—Ä—Ç.: {art}\n\n"
            f"{about}\n\n"
            f"–î–æ—Å—Ç—É–ø–Ω—ñ —Ä–æ–∑–º—ñ—Ä–∏:\n{props}\n"
            f"üí≤ –¶—ñ–Ω–∞: <b>{price_str}</b> üí≤\n\n"
            f'–î–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –ø–∏—à—ñ—Ç—å - <a href="tg://user?id={bot.get_me().id}">–ë–æ—Çü§ñ</a>\n\n'
            f"{hashtag_str}"
        )
        log(user_id, f'Message formed successfully for {art}')
        return szResultMessage

    except Exception as e:
        log(user_id, f'[ERROR] Failed to form message for {data.get("art", "---")}: {e}')
        return "NULL"


def sendMessage():
    try:
        DataList = fetch_as_dicts("SELECT * FROM products")
        log_sys(f'{len(DataList)} products fetched from database')

        for idx, data in enumerate(DataList):
            if idx == config["LastSendedIndex"]:
                art = data.get("art", "---")
                if data.get('active', False):
                    log_sys(f'Processing active product: {art}')
                    items = fetch_as_dicts(f'SELECT * FROM product_properties WHERE art = ?', (art,))
                    data['availabilityForProperties'] = {}
                    data['priceForProperties'] = {}
                    for item in items:
                        data['availabilityForProperties'][item["property"]] = item['availability']
                        data['priceForProperties'][item["property"]] = item['price']
                    log_sys(f'Properties loaded for {art}')

                    szResultMessage = formMessageText(data, 'system')
                    images = []

                    try:
                        if data.get("frontImage"):
                            images.append(open(data["frontImage"], 'rb'))
                            log_sys(f'Front image added for {art}')
                        if data.get("backImage"):
                            images.append(open(data["backImage"], 'rb'))
                            log_sys(f'Back image added for {art}')
                    except Exception as e:
                        log_sys(f'[ERROR] Failed to open image for {art}: {e}')

                    if images:
                        media = []
                        for i, img in enumerate(images):
                            if i == 0:
                                media.append(types.InputMediaPhoto(img, caption=szResultMessage, parse_mode='HTML'))
                            else:
                                media.append(types.InputMediaPhoto(img))
                        bot.send_media_group(config["channelID"], media)
                        log_sys(f'Message with images sent for {art}')
                    else:
                        bot.send_message(config["channelID"], szResultMessage, parse_mode='HTML')
                        log_sys(f'Message without images sent for {art}')

                    config["LastSendedIndex"] += 1
                    log_sys(f'LastSendedIndex updated to {config["LastSendedIndex"]}')

                    with open("config.json", "w", encoding="utf-8") as f:
                        json.dump(config, f, indent=4, ensure_ascii=False)
                        log_sys(f'Config saved after sending {art}')
                    return
                else:
                    log_sys(f'{art} is inactive, skipping')
                    config["LastSendedIndex"] += 1
                    with open("config.json", "w", encoding="utf-8") as f:
                        json.dump(config, f, indent=4, ensure_ascii=False)
                    sendMessage()

        log_sys(f'All products processed. Restarting index')
        config["LastSendedIndex"] = 0
        with open("config.json", "w", encoding="utf-8") as f:
            json.dump(config, f, indent=4, ensure_ascii=False)
        log_sys(f'LastSendedIndex reset to 0')
        sendMessage()

    except Exception as e:
        log_sys(f'[ERROR] Failed to send message: {e}')

for hour in range(config["fromHour"], config["toHour"]):
    time_str = f"{hour:02d}:00"
    schedule.every().day.at(time_str).do(sendMessage)

def run_scheduler():
    global scheduler_running
    while True:
        if scheduler_running:
            schedule.run_pending()
        time.sleep(config['timeToSleep'])

scheduler_thread = threading.Thread(target=run_scheduler)
scheduler_thread.start()

try:
    bot.infinity_polling()
except Exception as e:
    log_sys(f"[ERROR] Bot polling failed: {e}")
    input("Press Enter to exit...")